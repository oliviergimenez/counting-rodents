---
title: "Estimating coypus abundance"
author: "Olivier Gimenez"
date: "Dec 2024"
output: 
  html_document:
    toc: TRUE
    toc_depth: 2
    number_sections: true
    theme: united
    highlight: tango
    df_print: paged
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      cache = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      dpi = 600, 
                      fig.height=6, 
                      fig.width = 1.777777*6)
library(tidyverse)
theme_set(theme_light())
```

# Motivation

Show the hierarchical structure, and covariates on abundance and capture. Also scratches surface of lack of fit w/ overdispersion and negative binomial instead of poisson. 

```{r}
library(sf)
library(tidyverse)
library(janitor)
library(lubridate)
library(unmarked)
```

# Get data

Fonds de carte
```{r}
departements <- st_read("shp/departements-d-occitanie.shp")
mask <- departements$nom_officie.2 == "HERAULT" 
herault <- departements[mask, ]
communes <- st_read("shp/georef-france-commune-millesime.shp")
communes_herault <- communes %>% st_intersection(herault)
```


```{r}
ggplot() +
  geom_sf(data = herault, color = "black", lwd = 1) +
  geom_sf(data = communes_herault, lwd = .3, color = "black", fill = "white") + 
  theme_void()
```


```{r}
noms_communes_piegeage <- c("BAILLARGUES",
                            "CANDILLARGUES",
                            "LA GRANDE-MOTTE",
                            "LANSARGUES",
                            "MARSILLARGUES",
                            "MAUGUIO",
                            "SAINT-NAZAIRE-DE-PÉZAN",
                            "TEYRAN",
                            "ENTRE-VIGNES", #"SAINT-CHRISTOL",
                            "SAINT-AUNÈS",
                            "VALERGUES",
                            "SAINT-JUST",
                            "SAINT-GENIÈS-DES-MOURGUES",
                            "PÉROLS",
                            "LUNEL-VIEL",
                            "LUNEL",
                            "SAINT-VINCENT-DE-BARBEYRARGUES")
communes_piegeage <- communes_herault[communes_herault$com_name_up %in% noms_communes_piegeage,]
```


```{r}
ggplot() +
  geom_sf(data = herault, color = "black", lwd = 1) +
  geom_sf(data = communes_herault, lwd = .3, color = "black", fill = "white") + 
  geom_sf(data = communes_piegeage, lwd = .3, fill = "pink") + 
  theme_void()
```

Removal data
```{r}
raw_dat <- readRDS("data/coypus.rds")
```


```{r}
raw_dat$removal_coypus %>%
  filter(commune %in% c("candillargues",
                        "lansargues",
                        "mauguio",
                        "saint_nazaire_de_pezan",
                        "saint_just",
                        "valergues")) %>%
  filter(Month %in% c(2,3,4)) %>%
  filter(Year %in% 2022) %>%
  group_by(commune, Month) %>%
  summarize(tot = sum(n)) %>%
  ggplot() + 
  geom_col(aes(as_factor(Month), tot)) +
  facet_wrap(~commune) +
  labs(y = "nombre de ragondins", x = "années")
```


```{r}
captures_wide <- raw_dat$removal_coypus %>%
  filter(commune %in% c("candillargues",
                        "lansargues",
                        "mauguio",
                        "saint_nazaire_de_pezan",
                        "saint_just",
                        "valergues")) %>%
  filter(Month %in% c(2,3,4)) %>%
  # mutate(Year = as_factor(Year)) %>%
  pivot_wider(names_from = Month, 
              values_from = n)
```


```{r}
captures_wide
```


```{r}
pick_year <- 2022
dat <- captures_wide %>%
  filter(Year == pick_year)
```

# Model fitting

## Poisson

```{r}
K <- nrow(dat) # nsites
J <- ncol(dat[,-c(1,2)]) # nsurveys
constants <- list(K = K, J = J) 
data <- list(y = dat[,-c(1,2)],
             n = apply(dat[,-c(1,2)], 1, sum),
             temp = (raw_dat$temperature - mean(raw_dat$temperature))/sd(raw_dat$temperature),
             rain = (raw_dat$rainfall - mean(raw_dat$rainfall))/sd(raw_dat$rainfall),
             offset = raw_dat$favorable_habitat)
```


```{r}
library(nimble)
library(MCMCvis)
```


```{r}
# code
code <- nimbleCode({
  for (i in 1:K) { # loop over sites
    
    # prob of cells
    pi[i,1] <- p[i,1] # survey 1
    for(j in 2:J){ # loop over surveys > 1
      pi[i,j] <- prod(1 - p[i,1:(j-1)]) * p[i,j]
    }
    pcap[i] <- sum(pi[i,1:J])
    
    # capture prob
    for(j in 1:J){ # loop over surveys
      cloglog(p[i,j]) <- alpha[j]
      pic[i,j] <- pi[i,j] / pcap[i]
    }
    
    # likelihood: observation
    y[i,1:J] ~ dmulti(pic[i,1:J], n[i]) # multinomial for each site
    n[i] ~ dbin(pcap[i], N[i]) # for each site
    # likelihood: process
    N[i] ~ dpois(lambda[i]) # for each site
    log(lambda[i]) <- beta[1] + beta[2] * temp[i] + beta[3] * rain[i] + log(offset[i]) #+ eps[i] # for each site
  } # end of loop over sites
  
  for (j in 1:J){
    alpha[j] ~ dnorm(0, sd = 1.5)
  }
  for (k in 1:3){
    beta[k] ~ dnorm(0, sd = 1.5)
  }
})
```


```{r}
# initial values
pic.init <- array(runif(K*J,0.05,0.15), c(K,J))
pic.init <- pic.init / apply(pic.init, 1, sum)
apply(pic.init, 1, sum)
Nin <- apply(dat[,-c(1,2)], 1, sum) + 10
inits <- function(){list(alpha = rep(0.1, J), 
                         pic = pic.init, 
                         beta = rep(0,3), 
                     #    sigman = 1,
                         N = Nin)}
```


```{r}
# create Nimble model
Rmodel <- nimbleModel(code = code, 
                      constants = constants, 
                      data = data, 
                      inits = inits())
Rmcmc <- compileNimble(Rmodel, showCompilerOutput = F)
#ModSpec <- configureMCMC(Rmodel, onlyRW = TRUE) # RW sampling 
ModSpec <- configureMCMC(Rmodel, onlySlice = TRUE) # slice sampling 
#ModSpec <- configureMCMC(Rmodel) # Nimble picks the samplers
ModSpec$resetMonitors()
#ModSpec$addMonitors(c("alpha","N","beta", "sigman"))
ModSpec$addMonitors(c("alpha","N","beta"))
Cmcmc <- buildMCMC(ModSpec)
Cmodel <- compileNimble(Cmcmc, project = Rmodel, resetFunctions = TRUE)
```


```{r}
# run MCMC
ni <- 50000*4
nb <- 5000*4
nc <- 2
nt <- 15
samp <- runMCMC(Cmodel, 
                niter = ni, 
                nburnin = nb, 
                nchains = nc, 
                thin = nt, 
                inits = inits,  
                samplesAsCodaMCMC = TRUE)
```


```{r}
# post-process results
res <- rbind(samp$chain1, samp$chain2)
```


```{r}
# capture probabilities
data.frame(
  mois = c("janvier", "février", "mars"), 
  prob_capture = c(mean(icloglog(res[,'alpha[1]'])) * 100,
                   mean(icloglog(res[,'alpha[2]'])) * 100,
                   mean(icloglog(res[,'alpha[3]'])) * 100),
  IClower = c(quantile(icloglog(res[,'alpha[1]']), probs = c(2.5)/100)* 100,
                   quantile(icloglog(res[,'alpha[2]']), probs = c(2.5)/100)* 100,
                   quantile(icloglog(res[,'alpha[3]']), probs = c(2.5)/100)* 100),
  ICupper = c(quantile(icloglog(res[,'alpha[1]']), probs = c(97.5)/100)* 100,
              quantile(icloglog(res[,'alpha[2]']), probs = c(97.5)/100)* 100,
              quantile(icloglog(res[,'alpha[3]']), probs = c(97.5)/100)* 100))
```


```{r}
# expected abundance
data.frame(commune = c("candillargues",
                       "lansargues",
                       "mauguio",
                       "saint-nazaire-de-pézan",
                       "saint-just",
                       "valergues"),
           estimation = paste0(round(apply(res[,1:6], 2, mean)), ' (', 
                               round(apply(res[,1:6], 2, quantile, probs = c(2.5, 97.5)/100))[1,], ',',
                               round(apply(res[,1:6], 2, quantile, probs = c(2.5, 97.5)/100))[2,], ')'),
           prélèvements = apply(dat[,-c(1,2)],1,sum), 
           reste = round(apply(res[,1:6], 2, mean)) - apply(dat[,-c(1,2)],1,sum))
```


```{r}
MCMCsummary(samp, params=c("alpha","beta"))
```


```{r}
MCMCtrace(samp, params = c("alpha","beta"), pdf = FALSE)
```

## Overdispersion and neg binomial 

```{r}
# see https://georgederpa.github.io/teaching/countModels.html
code <- nimbleCode({
  for (i in 1:K) { # loop over sites
    
    # prob of cells
    pi[i,1] <- p[i,1] # survey 1
    for(j in 2:J){ # loop over surveys > 1
      pi[i,j] <- prod(1 - p[i,1:(j-1)]) * p[i,j]
    }
    pcap[i] <- sum(pi[i,1:J])
    
    # capture prob fn of effort
    for(j in 1:J){ # loop over surveys
      cloglog(p[i,j]) <- alpha[j] 
      pic[i,j] <- pi[i,j] / pcap[i]
    }
    
    # likelihood: observation
    y[i,1:J] ~ dmulti(pic[i,1:J], n[i]) # multinomial for each site
    n[i] ~ dbin(pcap[i], N[i]) # for each site
    # likelihood: process
    N[i] ~ dnegbin(pp[i], r)
    pp[i] <- r / (r + lambda[i]) 
    log(lambda[i]) <- beta[1] + beta[2] * temp[i] + beta[3] * rain[i] + log(offset[i]) #+ eps[i] # for each site
    #    eps[i] ~ dnorm(0, sd = sigman)
  } # end of loop over sites
  
  r ~ dunif(0.01,50)
  
  for (j in 1:J){
    alpha[j] ~ dnorm(0, sd = 1.5)
  }
  for (k in 1:3){
    beta[k] ~ dnorm(0, sd = 1.5)
  }
  #  sigman ~ dunif(0, 10)
})
```


```{r}
# initial values
pic.init <- array(runif(K*J,0.05,0.15), c(K,J))
pic.init <- pic.init / apply(pic.init, 1, sum)
apply(pic.init, 1, sum)
Nin <- apply(dat[,-c(1,2)], 1, sum) + 10
inits <- function(){list(alpha = rep(0.1, J), 
                         pic = pic.init, 
                         beta = rep(0,3), 
                         #    sigman = 1,
                         N = Nin)}
```


```{r}
# create  Nimble model
Rmodel <- nimbleModel(code = code, 
                      constants = constants, 
                      data = data, 
                      inits = inits())
Rmcmc <- compileNimble(Rmodel, showCompilerOutput = F)
#ModSpec <- configureMCMC(Rmodel, onlyRW = TRUE) # RW sampling 
ModSpec <- configureMCMC(Rmodel, onlySlice = TRUE) # slice sampling 
#ModSpec <- configureMCMC(Rmodel) # Nimble picks the samplers
ModSpec$resetMonitors()
#ModSpec$addMonitors(c("alpha","N","beta", "sigman"))
ModSpec$addMonitors(c("alpha","N","beta","r"))
Cmcmc <- buildMCMC(ModSpec)
Cmodel <- compileNimble(Cmcmc, project = Rmodel, resetFunctions = TRUE)
```


```{r}
# run MCMC
ni <- 50000*4
nb <- 5000*4
nc <- 2
nt <- 15

samp <- runMCMC(Cmodel, 
                niter = ni, 
                nburnin = nb, 
                nchains = nc, 
                thin = nt, 
                inits = inits,  
                samplesAsCodaMCMC = TRUE)
```


```{r}
res <- rbind(samp$chain1, samp$chain2)
```


```{r}
# capture probabilities
data.frame(
  mois = c("janvier", "février", "mars"), 
  prob_capture = c(mean(icloglog(res[,'alpha[1]'])) * 100,
                   mean(icloglog(res[,'alpha[2]'])) * 100,
                   mean(icloglog(res[,'alpha[3]'])) * 100),
  IClower = c(quantile(icloglog(res[,'alpha[1]']), probs = c(2.5)/100)* 100,
              quantile(icloglog(res[,'alpha[2]']), probs = c(2.5)/100)* 100,
              quantile(icloglog(res[,'alpha[3]']), probs = c(2.5)/100)* 100),
  ICupper = c(quantile(icloglog(res[,'alpha[1]']), probs = c(97.5)/100)* 100,
              quantile(icloglog(res[,'alpha[2]']), probs = c(97.5)/100)* 100,
              quantile(icloglog(res[,'alpha[3]']), probs = c(97.5)/100)* 100))
```


```{r}
# expected abundance
data.frame(commune = c("candillargues",
                       "lansargues",
                       "mauguio",
                       "saint-nazaire-de-pézan",
                       "saint-just",
                       "valergues"),
           estimation = paste0(round(apply(res[,1:6], 2, mean)), ' (', 
                               round(apply(res[,1:6], 2, quantile, probs = c(2.5, 97.5)/100))[1,], ',',
                               round(apply(res[,1:6], 2, quantile, probs = c(2.5, 97.5)/100))[2,], ')'),
           prélèvements = apply(dat[,-c(1,2)],1,sum), 
           reste = round(apply(res[,1:6], 2, mean)) - apply(dat[,-c(1,2)],1,sum))
```


```{r}
MCMCsummary(samp, params=c("alpha","beta", "r"))
```


```{r}
MCMCtrace(samp, params = c("alpha","beta", "r"), pdf = FALSE)
```

## UMBS

```{r}
library(ubms)
```


```{r}
y <- as.matrix(dat[,-c(1,2)])
site.covs <- data.frame(temp = (raw_dat$temperature - mean(raw_dat$temperature))/sd(raw_dat$temperature),
                        rain = (raw_dat$rainfall - mean(raw_dat$rainfall))/sd(raw_dat$rainfall),
                        fh = raw_dat$favorable_habitat)

time <- matrix(c('january','february','march'),
               nrow = nrow(y),
               ncol = ncol(y), 
               byrow = TRUE)

umf <- unmarkedFrameMPois(y = y, 
                        siteCovs = site.covs,
                        obsCovs = list(time = time),
                        type = "removal")
```


```{r}
fit <- stan_multinomPois(~time ~temp + rain + offset(log(fh)), 
                        data = umf, 
                        chains = 2, 
                        iter = 5000,
                        prior_intercept_state = normal(0, 1.5),
                        prior_coef_state = normal(0, 1.5))
```

Estimates for abundance parameters are similar to NIMBLE.
```{r}
fit
```


```{r}
traceplot(fit, pars = c("beta_state", "beta_det"))
```


```{r}
plot_posteriors(fit)#, pars=c("beta_state[SistemaSilvopastoril]"))
```


Estimated relationships for abundance vs temperature and rainfall are similar to what we got with NIMBLE.
```{r}
plot_marginal(fit, submodel = "state")
```

Estimates for capture probabilities are similar to what we got with NIMBLE.
```{r}
plot_marginal(fit, submodel = "det")
```


# Session info

```{r}
sessionInfo()
```

